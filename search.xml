<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 添加用户 以及 SSH 无秘密操作]]></title>
    <url>%2F2018%2F01%2F18%2FVUEX%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[说明 操作系统为 Ubuntu 14.04 64位 // gpasswd 可以让xuchangjian 用户使用 sudo的权限 但是必须要输入密码 gpasswd -a xuchangjian sudo //这步只是将xuchangjian 添加到sudo的用户组 sudo visudo service ssh restart SSH 无密码登录 在本地电脑中操作: cat ~/.ssh/id_rsa.pub //检查有无秘钥 eval &quot;$(ssh-agent -s)&quot; ssh-add ~/.ssh/id_rsa 然后再服务器端 ： ssh-keygen -t rsa -b 4096 -C &quot;189323200@qq.com&quot; eval &quot;$(ssh-agent -s)&quot; ssh-add ~/.ssh/id_rsa cd ~/.ssh vi authorized_keys //打开这个文件的编辑器 将本地的ssh key 粘贴进去 保存 chmod 600 authorized_keys //是授权这个文件 sudo service ssh restart //重启下]]></content>
      <categories>
        <category>服务器</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB]]></title>
    <url>%2F2018%2F01%2F16%2FMongoDB%2F</url>
    <content type="text"><![CDATA[MongoDB 安装及配置 本安装配置在Ubuntu 14.0官方链接：https://docs.mongodb.com/manual/administration/install-on-linux/ 安装1. 将公共的key 使用在系统中sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5 2. 为MongoDB创建一个列表文件echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list 3. 更新本地数据包sudo apt-get update 4. 安装数据库sudo apt-get install -y mongodb-org or 安装指定版本 sudo apt-get install -y mongodb-org=3.6.2 mongodb-org-server=3.6.2 mongodb-org-shell=3.6.2 mongodb-org-mongos=3.6.2 mongodb-org-tools=3.6.2 以上步骤注意操作即可； MongoDB 命令1. 启动MongoDBsudo service mongod start 2. 停止MongoDBsudo service mongod stop 3. 重启MongoDBsudo service mongod restart 4.开始使用MongoDBmongo --port 27018 如果希望可以通过外面访问服务器的数据库可以 修改MongoDB的配置文件 sudo vi /etc/mongod.conf 将端口修改自己想要的 将ip改成0.0.0.0 (表示所有ip都可以访问),然后在阿里云服务器安全组中 把端口暴露出去即可 5.移除包sudo apt-get purge mongodb-org* 6.移除项目目录(卸载) 移除MongoDB 数据库 和 log 文件 sudo rm -r /var/log/mongodb sudo rm -r /var/lib/mongodb MongoDB 基本配置转载自：http://blog.csdn.net/xiaoxing598/article/details/54233044 –quiet # 安静输出–port arg # 指定服务端口号，默认端口27017–bind_ip arg # 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP–logpath arg # 指定MongoDB日志文件，注意是指定文件不是目录–logappend # 使用追加的方式写日志–pidfilepath arg # PID File 的完整路径，如果没有设置，则没有PID文件–keyFile arg # 集群的私钥的完整路径，只对于Replica Set 架构有效–unixSocketPrefix arg # UNIX域套接字替代目录,(默认为 /tmp)–fork # 以守护进程的方式运行MongoDB，创建服务器进程–auth # 启用验证–cpu # 定期显示CPU的CPU利用率和iowait–dbpath arg # 指定数据库路径–diaglog arg # diaglog选项 0=off 1=W 2=R 3=both 7=W+some reads–directoryperdb # 设置每个数据库将被保存在一个单独的目录–journal # 启用日志选项，MongoDB的数据操作将会写入到journal文件夹的文件里–journalOptions arg # 启用日志诊断选项–ipv6 # 启用IPv6选项–jsonp # 允许JSONP形式通过HTTP访问（有安全影响）–maxConns arg # 最大同时连接数 默认2000–noauth # 不启用验证–nohttpinterface # 关闭http接口，默认关闭27018端口访问–noprealloc # 禁用数据文件预分配(往往影响性能)–noscripting # 禁用脚本引擎–notablescan # 不允许表扫描–nounixsocket # 禁用Unix套接字监听–nssize arg (=16) # 设置信数据库.ns文件大小(MB)–objcheck # 在收到客户数据,检查的有效性，–profile arg # 档案参数 0=off 1=slow, 2=all–quota # 限制每个数据库的文件数，设置默认为8–quotaFiles arg # number of files allower per db, requires –quota–rest # 开启简单的rest API–repair # 修复所有数据库run repair on all dbs–repairpath arg # 修复库生成的文件的目录,默认为目录名称dbpath–slowms arg (=100) # value of slow for profile and console log–smallfiles # 使用较小的默认文件–syncdelay arg (=60) # 数据写入磁盘的时间秒数(0=never,不推荐)–sysinfo # 打印一些诊断系统信息–upgrade # 如果需要升级数据库 MongoDB 增删改（CUD）操作# 运行shell，命令：mongo ip:port，在这里我使用的默认的端口所以就没有指定 [root@bogon mongodb-linux-x86_64-rhel70-3.4.1]# ./bin/mongo # 显示现有的数据库，命令：show dbs; &gt; show dbs admin 0.000GB local 0.000GB # 显示当前使用的数据库，命令：db &gt; db test # 切换当前使用的数据库，命令：use 数据库名称 &gt; use local switched to db local # 创建数据库：MongoDB没有专门创建数据库的语句，可以使用“use” 来使用某个数据库，如果要使用的数据库不存在，那么将会创建一个，会在真正向该库加入文档后，保存成为文件。 &gt; use mall switched to db mall # 删除数据库，命令：db.dropDatabase()，在使用这个命令前要记得切换到将被删除的数据，可以用上面学到的命令确认一下。 &gt; db mall &gt; db.dropDatabase() { &quot;dropped&quot; : &quot;mall&quot;, &quot;ok&quot; : 1 } # 显示现有的集合，命令：show collections，我们切换到一个新的数据库，到里面插入一个集合并保存一条数据，这样做只是为了造些语句便于演示这个命令。 &gt; use mall switched to db mall &gt; db.user.insert({name:&apos;张三&apos;}) WriteResult({ &quot;nInserted&quot; : 1 }) &gt; show collections user # 创建集合：在MongoDB中不用创建集合，因为没有固定的结构，直接使用db.集合名称.命令 来操作就可以了。如果非要显示创建集合的话，用：db.createCollecion(&apos;集合名称&apos;); &gt; db.createCollection(&apos;system&apos;) { &quot;ok&quot; : 1 } # 插入并保存文档 # insert方法，可以单独插入一个文档，也可以插入多个，用“[ ]”即可。注意： # 1：MongoDB会为每个没有“_id”字段的文档自动添加一个”_id”字段 # 2：每个Doc必须小于16MB # 上面已经有演示，这里就不再赘述 # 删除文档，命令：remove ， 可以按条件来删除只是删除文档，集合还在，如果使用 drop命令，会连带集合和索引都删掉 # 查看集合中所有的文档，命令：db.集合名称.find(); &gt; db.user.find() { &quot;_id&quot; : ObjectId(&quot;5871e5f99423674edcea4eec&quot;), &quot;name&quot; : &quot;张三&quot; } &gt; db.user.remove({}) WriteResult({ &quot;nRemoved&quot; : 1 }) &gt; db.user.find() &gt; # 查看集合的状态信息：db.集合名.stats(); &gt; db.user.stats() { &quot;ns&quot; : &quot;mall.user&quot;, &quot;size&quot; : 0, &quot;count&quot; : 0, &quot;storageSize&quot; : 20480, &quot;capped&quot; : false, &quot;wiredTiger&quot; : {...}, ... } # 查看集合中第一个文档，命令：db.集合名称.findOne({条件对象})，造一些数据方便测试 &gt; db.user.insert([{name:&apos;李四&apos;},{name:&apos;王五&apos;}]) BulkWriteResult({ &quot;writeErrors&quot; : [ ], &quot;writeConcernErrors&quot; : [ ], &quot;nInserted&quot; : 2, &quot;nUpserted&quot; : 0, &quot;nMatched&quot; : 0, &quot;nModified&quot; : 0, &quot;nRemoved&quot; : 0, &quot;upserted&quot; : [ ] }) &gt; db.user.findOne() { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eed&quot;), &quot;name&quot; : &quot;李四&quot; } # 文档替换，命令： db.集合名称. update(条件，新的文档); &gt; db.user.update({name:&apos;王五&apos;}, {name:&apos;王五&apos;,sex:&apos;男&apos;}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find() { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eed&quot;), &quot;name&quot; : &quot;李四&quot; } { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eee&quot;), &quot;name&quot; : &quot;王五&quot;, &quot;sex&quot; : &quot;男&quot; } # 上面的操作说明：先找到名称是王五的这一条记录，然后用新文档替换数据原来的所有值，是一个整体替换的操作。 # save方法 # 如果文档存在就更新，不存在就新建，主要根据”_id”来判断。可以看到我们插入了一个名称相同的文档，结果是成功的。 &gt; db.user.save({name:&apos;李四&apos;}) WriteResult({ &quot;nInserted&quot; : 1 }) &gt; db.user.find() { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eed&quot;), &quot;name&quot; : &quot;李四&quot; } { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eee&quot;), &quot;name&quot; : &quot;王五&quot;, &quot;sex&quot; : &quot;男&quot; } { &quot;_id&quot; : ObjectId(&quot;5871eb8e9423674edcea4eef&quot;), &quot;name&quot; : &quot;李四&quot; } # upsert # 找到了符合条件的文档就更新，否则会以这个条件和更新文档来创建一个新文档。指定update方法的第三个参数为true，可表示是upsert &gt; db.user.update({name:&quot;张三&quot;}, {name:&quot;张三&quot;,sex:&apos;女&apos;}) WriteResult({ &quot;nMatched&quot; : 0, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 }) &gt; db.user.find() { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eed&quot;), &quot;name&quot; : &quot;李四&quot; } { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eee&quot;), &quot;name&quot; : &quot;王五&quot;, &quot;sex&quot; : &quot;男&quot; } { &quot;_id&quot; : ObjectId(&quot;5871eb8e9423674edcea4eef&quot;), &quot;name&quot; : &quot;李四&quot; } # 上面的修改没有成功，原因就在于根据条件查询不到张三这个文档，那下面我们给他换上第三个参数。我们希望找不到就增加，找到就修改。 &gt; db.user.update({name:&quot;张三&quot;}, {name:&quot;张三&quot;,sex:&apos;女&apos;}, true) WriteResult({ &quot;nMatched&quot; : 0, &quot;nUpserted&quot; : 1, &quot;nModified&quot; : 0, &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;) }) &gt; db.user.find() { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eed&quot;), &quot;name&quot; : &quot;李四&quot; } { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eee&quot;), &quot;name&quot; : &quot;王五&quot;, &quot;sex&quot; : &quot;男&quot; } { &quot;_id&quot; : ObjectId(&quot;5871eb8e9423674edcea4eef&quot;), &quot;name&quot; : &quot;李四&quot; } { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;女&quot; } #大家请看上面的操作，从查询出来的结果中我们看到，要修改的记录没有找到就变成新增操作了。 # 查询更新了多少个文档 # 使用命令：getLastError ，返回最后一次操作的相关信息，里面的n就是更新的文档的数量。 &gt; db.runCommand({&quot;getLastError&quot;:1}) { &quot;connectionId&quot; : 3, &quot;n&quot; : 0, &quot;syncMillis&quot; : 0, &quot;writtenTo&quot; : null, &quot;err&quot; : null, &quot;ok&quot; : 1 } 更复杂的操作 # 我准备了测试数据如下 &gt; db.user.find() { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eed&quot;), &quot;name&quot; : &quot;李四&quot; } { &quot;_id&quot; : ObjectId(&quot;5871e8fe9423674edcea4eee&quot;), &quot;name&quot; : &quot;王五&quot;, &quot;sex&quot; : &quot;男&quot; } { &quot;_id&quot; : ObjectId(&quot;5871eb8e9423674edcea4eef&quot;), &quot;name&quot; : &quot;李四&quot; } { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;女&quot; } # 1：$set ：指定一个字段的值，如果字段不存在，会创建一个 &gt; db.user.update({name:&apos;张三&apos;}, {$set:{sex:&apos;保密&apos;}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot; } # 如果指定修改的字段不存在则新增加 &gt; db.user.update({name:&apos;张三&apos;}, {$set:{nick:&apos;小三&apos;}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;nick&quot; : &quot;小三&quot; } # 2：$unset ：删掉某个字段 &gt; db.user.update({name:&apos;张三&apos;}, {$unset:{nick:1}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot; } # 3：$inc ：用来增加已有键的值，如果字段不存在，会创建一个。只能用于整型、长整型、或双精度浮点型的值。 &gt; db.user.update({name:&apos;张三&apos;}, {$inc:{age:12}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12 } # 4：$push：向已有数组的末尾加入一个元素，要是没有就新建一个数组 &gt; db.user.update({name:&apos;张三&apos;}, {$set:{group:[4,2]}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 4, 2 ] } &gt; db.user.update({name:&apos;张三&apos;}, {$push:{group:5}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 4, 2, 5 ] } # 5：$each：通过一次$push来操作多个值，同时push多个值 &gt; db.user.update({name:&apos;张三&apos;}, {$push:{group:{$each:[4,2,6,5]}}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 4, 2, 5, 4, 2, 6, 5 ] } # 6：$slice：限制数组只包含最后加入的n个元素，其值必须是负整数 &gt; db.user.update({name:&apos;张三&apos;}, {$push:{group:{$each:[4,2,6,5],$slice:-3}}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 2, 6, 5 ] } # 7：$sort：对数组中的元素，按照指定的字段来对数据进行排序（1为升序，-1为降序），然后再按照slice删除。注意：不能只将$slice或者$sort与$push配合使用，且必须使用$each &gt; db.user.update({name:&apos;张三&apos;}, {$push:{group:{$each:[4,2,6,5],$slice:-3, $sort:1}}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 5, 6, 6 ] } # 8：$ne：判断一个值是否在数组中，如果不在则添加进去 &gt; db.user.update({name:&apos;张三&apos;, group:{$ne:7}}, {$push:{group:7}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 5, 6, 6, 7 ] } &gt; db.user.update({name:&apos;张三&apos;, group:{$ne:7}}, {$push:{group:7}}) WriteResult({ &quot;nMatched&quot; : 0, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 5, 6, 6, 7 ] } # 9：$addToSet：将数组作为数据集使用，以保证数组内的元素不会重复 &gt; db.user.update({name:&apos;张三&apos;}, {$addToSet:{group:7}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 0 }) # 10：$pop ：从数组一端删除元素，{$pop:{key:1}}，从末尾删掉一个，-1则从头部删除 &gt; db.user.update({name:&apos;张三&apos;}, {$pop:{group:1}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) # 11：$pull：按照条件来删除所有匹配的元素 &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 5, 6, 6, 7, 7 ] } &gt; db.user.update({name:&apos;张三&apos;}, {$pull:{group:7}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 5, 6, 6 ] } # 12：$：用来修改第一个匹配的元素 &gt; db.user.update({name:&apos;张三&apos;}, {$set:{&apos;group.2&apos;:8}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 5, 6, 8 ] } # 像上面这种就是根据数组的索引来替换值 &gt; db.user.update({name:&apos;张三&apos;, &apos;group.1&apos;:6}, {$set:{&apos;group.$&apos;:4}}) WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 }) &gt; db.user.find({name:&apos;张三&apos;}) { &quot;_id&quot; : ObjectId(&quot;5871ecba7f264dfcaeec2489&quot;), &quot;name&quot; : &quot;张三&quot;, &quot;sex&quot; : &quot;保密&quot;, &quot;age&quot; : 12, &quot;group&quot; : [ 5, 4, 8 ] }]]></content>
      <categories>
        <category>后端</category>
        <category>NODE</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>NODE</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express]]></title>
    <url>%2F2018%2F01%2F13%2FEXPRESS%2F</url>
    <content type="text"><![CDATA[#express 简述 express 是什么Express是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。 express 中间件中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件。 每个中间件可以从App实例，接收三个参数，依次为request对象（代表HTTP请求）、response对象（代表HTTP回应），next回调函数（代表下一个中间件）。每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。 一个不进行任何操作、只传递request对象的中间件，就是下面这样。 function uselessMiddleware(req, res, next) { next(); } 上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本。 function uselessMiddleware(req, res, next) { next(&apos;出错了！&apos;); } express 运行原理Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下。 var http = require(&quot;http&quot;); var app = http.createServer(function(request, response) { response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;}); response.end(&quot;Hello world!&quot;); }); app.listen(3000, &quot;localhost&quot;); 上面代码的关键是http模块的createServer方法，表示生成一个HTTP服务器实例。该方法接受一个回调函数，该回调函数的参数，分别为代表HTTP请求和HTTP回应的request对象和response对象。 Express框架的核心是对http模块的再包装。上面的代码用Express改写如下。 var express = require(&apos;express&apos;); var app = express(); app.get(&apos;/&apos;, function (req, res) { res.send(&apos;Hello world!&apos;); }); app.listen(3000); 比较两段代码，可以看到它们非常接近。原来是用http.createServer方法新建一个app实例，现在则是用Express的构造方法，生成一个Epress实例。两者的回调函数都是相同的。Express框架等于在http模块之上，加了一个中间层。 express 准备工作利用express 自带的生成器初始化项目 npm install express-generator -g express-generator是Express4自带的命令行工具，用来初始化Express项目，所以只需要将其全局安装，而不需要将整个Express全局安装，这和Express3不同，在Express3中，命令行集成在整个Express项目中，所以必须将Express3全局安装。 使用express命令初始化项目 express --git -f express命令有一些可选参数，具体可以参看官方文档。这里我们只用到了两个。 –git ：告知express生成.gitignore文件，这个文件定义了git需要忽略控制的文件，通常node_mondules会被写到此文件里。 -f ：当目标文件夹不为空时，仍然强制执行。这里加此选项的原因是因为我们clone下来的项目里原本含有LICENSE 和 README.md两个文件。 然后 npm install 安装依赖即可 启动这个应用（MacOS 或 Linux 平台）： DEBUG=myapp npm start Windows 平台使用如下命令： set DEBUG=myapp &amp; npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。 Express 的方法use() 方法use是express注册中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子。 var express = require(&quot;express&quot;); var http = require(&quot;http&quot;); var app = express(); app.use(function(request, response, next) { console.log(&quot;In comes a &quot; + request.method + &quot; to &quot; + request.url); next(); }); app.use(function(request, response) { response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; }); response.end(&quot;Hello world!\n&quot;); }); http.createServer(app).listen(1337); 上面代码使用app.use方法，注册了两个中间件。收到HTTP请求后，先调用第一个中间件，在控制台输出一行信息，然后通过next方法，将执行权传给第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以request对象就不再向后传递了。 use方法内部可以对访问路径进行判断，据此就能实现简单的路由，根据不同的请求网址，返回不同的网页内容。 var express = require(&quot;express&quot;); var http = require(&quot;http&quot;); var app = express(); app.use(function(request, response, next) { if (request.url == &quot;/&quot;) { response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; }); response.end(&quot;Welcome to the homepage!\n&quot;); } else { next(); } }); app.use(function(request, response, next) { if (request.url == &quot;/about&quot;) { response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; }); } else { next(); } }); app.use(function(request, response) { response.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; }); response.end(&quot;404 error!\n&quot;); }); http.createServer(app).listen(1337); 上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。注意，app.use方法一共登记了三个中间件，只要请求路径匹配，就不会将执行权交给下一个中间件。因此，最后一个中间件会返回404错误，即前面的中间件都没匹配请求路径，找不到所要请求的资源。 除了在回调函数内部判断请求的网址，use方法也允许将请求网址写在第一个参数。这代表，只有请求路径匹配这个参数，后面的中间件才会生效。无疑，这样写更加清晰和方便。 app.use(&apos;/path&apos;, someMiddleware); all方法和HTTP动词方法针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写。 var express = require(&quot;express&quot;); var http = require(&quot;http&quot;); var app = express(); app.all(&quot;*&quot;, function(request, response, next) { response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; }); next(); }); app.get(&quot;/&quot;, function(request, response) { response.end(&quot;Welcome to the homepage!&quot;); }); app.get(&quot;/about&quot;, function(request, response) { response.end(&quot;Welcome to the about page!&quot;); }); app.get(&quot;*&quot;, function(request, response) { response.end(&quot;404!&quot;); }); http.createServer(app).listen(1337); 上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了。 除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法。 这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配。 注意：app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。 app.all(&apos;/secret&apos;, function (req, res, next) { console.log(&apos;Accessing the secret section ...&apos;); next(); // pass control to the next handler }); set方法set方法用于指定变量的值。 app.set(&quot;views&quot;, __dirname + &quot;/views&quot;); app.set(&quot;view engine&quot;, &quot;jade&quot;); 上面代码使用set方法，为系统变量“views”和“view engine”指定值。 response对象1. response.redirect方法: response.redirect方法允许网址的重定向。 response.redirect(&quot;/hello/anime&quot;); response.redirect(&quot;http://www.example.com&quot;); response.redirect(301, &quot;http://www.example.com&quot;); 2. response.sendFile方法: response.sendFile方法用于发送文件。以八位字节流的形式发送文件。 response.sendFile(&quot;/path/to/anime.mp4&quot;); 3. response.render方法: response.render方法用于渲染网页模板。 app.get(&quot;/&quot;, function(request, response) { response.render(&quot;index&quot;, { message: &quot;Hello World&quot; }); }); //上面代码使用render方法，将message变量传入index模板，渲染成HTML网页。 4. response.render方法: response.render方法用于渲染网页模板。下面代码使用render方法，将message变量传入index模板，渲染成HTML网页。 app.get(&quot;/&quot;, function(request, response) { response.render(&quot;index&quot;, { message: &quot;Hello World&quot; }); }); 5. res.json方法: 发送一个 JSON 格式的响应。 6.res.end方法: 终结响应处理流程。 7.res.sendStatus方法: 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 res.sendStatus(200); // equivalent to res.status(200).send(&apos;OK&apos;) res.sendStatus(403); // equivalent to res.status(403).send(&apos;Forbidden&apos;) res.sendStatus(404); // equivalent to res.status(404).send(&apos;Not Found&apos;) res.sendStatus(500); // equivalent to res.status(500).send(&apos;Internal ServerError&apos;) 8.res.cookie(name, value [, options])方法:cookie的创建: express直接提供了api,只需要在需要使用的地方调用如下api即可 function(req, res, next){ ... res.cookie(name, value [, options]); ... } express就会将其填入Response Header中的Set-Cookie，达到在浏览器中设置cookie的作用。 name: 类型为String value: 类型为String和Object，如果是Object会自动调用JSON.stringify对其进行处理 Option: 类型为对象，可使用的属性如下： domain：cookie在什么域名下有效，类型为String,。默认为网站域名expires: cookie过期时间，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。httpOnly: 只能被web server访问，类型Boolean。maxAge: 实现expires的功能，设置cookie过期的时间，类型为String，指明从现在开始，多少毫秒以后，cookie到期。path: cookie在什么路径下有效，默认为’/‘，类型为Stringsecure：只能被HTTPS使用，类型Boolean，默认为falsesigned:使用签名，类型Boolean，默认为false。express会使用req.secret来完成签名，需要cookie-parser配合使用 res.cookie(‘name’, ‘koby’, { domain: ‘.example.com’, path: ‘/admin’, secure: true });//cookie的有效期为900000msres.cookie(‘rememberme’, ‘1’, { expires: new Date(Date.now() + 900000), httpOnly: true });//cookie的有效期为900000msres.cookie(‘rememberme’, ‘1’, { maxAge: 900000, httpOnly: true }); //cookie的value为对象res.cookie(‘cart’, { items: [1,2,3] });res.cookie(‘cart’, { items: [1,2,3] }, { maxAge: 900000 }); res.cookie(‘name’, ‘tobi’, { signed: true }); cookie的删除express直接提供了api删除浏览器中的cookie,只需要在需要使用的地方调用如下api即可 function(req, res, next){ ... res.clearCookie(name [, options]); ... } 利用cookie-parser读取cookie npm install cookie-parser --save cookie-parser是一个非常好用方便的插件，可以直接用在express和connect中，官文地址为https://www.npmjs.com/package/cookie-parser。npm安装命令 var express = require(&apos;express&apos;); var cookieParser = require(&apos;cookie-parser&apos;); var app = express(); //不使用签名 app.use(cookieParser()); //挂载中间件，可以理解为实例化 //若需要使用签名，需要指定一个secret,字符串,否者会报错 app.use(cookieParser(&apos;Simon&apos;)); 获取cookie(无签名) var cookies = req.cookies # 获取cookie集合 var value = req.cookies.key # 获取名称为key的cookie的值 获取cookie(有签名) var cookies = req.signedCookies # 获取cookie集合var value = req.signedCookies.key # 获取名称为key的cookie的值 exmple: var express = require(&apos;express&apos;); var app = express(); var cookieParser = require(&apos;cookie-parser&apos;); //不使用签名 // app.use(cookieParser()); //挂载中间件，可以理解为实例化 //若需要使用签名，需要指定一个secret,字符串,否者会报错 app.use(cookieParser(&apos;simon&apos;)); // 设置cookie app.get(&apos;/setCookie&apos;, function (req, res, next) { req.secret = &apos;simon&apos;; //签名不能做到加密 只能做到防止篡改 res.cookie(&apos;name&apos;, &apos;iwen&apos;); res.cookie(&apos;signed1&apos;, &apos;signed2&apos;, {signed: true}); res.cookie(&apos;rememberme&apos;, &apos;1&apos;, {expires: new Date(Date.now() + 900000), httpOnly: true}); res.cookie(&apos;cart&apos;, {items: [1, 2, 3]}, {maxAge: 900000}); console.log(&quot;无签名的&quot;,req.cookies); console.log(&quot;有签名的&quot;,req.signedCookies); res.send(&apos;设置成功&apos;) }); app.listen(3333, function () { console.log(&apos;执行了&apos;) }); 9.res.session方法:npm install cookie-session cookieSession之前需要使用cookieParser中间件 var express =require(&apos;express&apos;); var app = express(); app.use(express.cookieParser(&apos;S3CRE7&apos;)); app.use(express.cookieSession(opt)); 中间件传递参数如下： key : cookie键，session_id；secret : 加密cookie值的字符串，与cookieParser中的secret功能完全相同，如果cookieParser没有传入secret参数，此处必须传入。个人角度为了主观上的感觉，采用了两个不同的值。cookie ： 设置cookie的相关参数，即除KV对之外的expire/maxAge,httpOnly,path值proxy ： 是否信任反向代理，默认false example: var express = require(&apos;express&apos;); var app = express(); var cookieParser = require(&apos;cookie-parser&apos;); const cookieSession = require(&apos;cookie-session&apos;); /* 使用session */ var session_arr = []; for (var i = 0; i &lt; 100000; i++) { session_arr.push(&apos;keys_&apos; + Math.random()); } app.use(cookieParser()); app.use(cookieSession({name: &apos;api_session_id&apos;, keys: session_arr})); // 设置cookie app.get(&apos;/setSession&apos;, function (req, res, next) { if (!req.session[&apos;count&apos;]) { req.session[&apos;count&apos;] = 1; } else { req.session[&apos;count&apos;]++; } console.log(&quot;访问次数&quot;, req.session[&apos;count&apos;]); res.send(&apos;设置成功&apos;) }); app.listen(3333, function () { console.log(&apos;执行了&apos;) }); requst对象request.ip request.ip属性用于获得HTTP请求的IP地址。 request.files request.files用于获取上传的文件。 req.bodynpm install body-parse --save bodyParser.json(options): 解析json数据 bodyParser.raw(options): 解析二进制格式(Buffer流数据) bodyParser.text(options): 解析文本数据 bodyParser.urlencoded(options): 解析UTF-8的编码的数据。 var bodyParser = require(&apos;body-parser&apos;); //创建 application/json 解析 app.use(bodyParser.json()) // 创建 application/x-www-form-urlencoded 解析 app.use(bodyParser.urlencoded({extended: false})) app.post(&apos;/post&apos;, function (req, res) { var params = req.body console.log(params) //{ params1: &apos;post_p1&apos;, params2: &apos;post_p2&apos; } }) bodyParser.json(options) :返回一个仅解析json格式数据的中间件。option可选对象: inflate - 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。 limit - 设置请求的最大数据量。默认为’100kb’ reviver - 传递给JSON.parse()方法的第二个参数，详见JSON.parse() strict - 设置为true时，仅会解析Array和Object两种格式；设置为false会解析所有JSON.parse支持的格式。默认为true type - 该选项用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/json。 verify - 这个选项仅在verify(req, res, buf, encoding)时受支持 bodyParser.urlencoded(options) 解析UTF-8的编码的数据。返回一个处理urlencoded数据的中间件。option可选值： extended - 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true inflate - 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。 limit - 设置请求的最大数据量。默认为’100kb’ parameterLimit - 用于设置URL编码值的最大数据。默认为1000 type - 该选项用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/octet-stream。 verify - 这个选项仅在verify(req, res, buf, encoding)时受支持 req.query 可以获得get请求参数 Express.Router用法从Express 4.0开始，路由器功能成了一个单独的组件Express.Router。它好像小型的express应用程序一样，有自己的use、get、param和route方法。 基本用法首先，Express.Router是一个构造函数，调用后返回一个路由器实例。然后，使用该实例的HTTP动词方法，为不同的访问路径，指定回调函数；最后，挂载到某个路径。 var router = express.Router(); router.get(&apos;/&apos;, function(req, res) { res.send(&apos;首页&apos;); }); router.get(&apos;/about&apos;, function(req, res) { res.send(&apos;关于&apos;); }); app.use(&apos;/&apos;, router); 上面代码先定义了两个访问路径，然后将它们挂载到根目录。如果最后一行改为app.use(‘/app’, router)，则相当于为/app和/app/about这两个路径，指定了回调函数。 这种路由器可以自由挂载的做法，为程序带来了更大的灵活性，既可以定义多个路由器实例，也可以为将同一个路由器实例挂载到多个路径。 router中间件use方法为router对象指定中间件，即在数据正式发给用户之前，对数据进行处理。下面就是一个中间件的例子。 router.use(function(req, res, next) { console.log(req.method, req.url); next(); }); 上面代码中，回调函数的next参数，表示接受其他中间件的调用。函数体中的next()，表示将数据传递给下一个中间件。 注意，中间件的放置顺序很重要，等同于执行顺序。而且，中间件必须放在HTTP动词方法之前，否则不会执行。 对路径参数的处理router对象的param方法用于路径参数的处理，可以 router.param(&apos;name&apos;, function(req, res, next, name) { // 对name进行验证或其他处理…… console.log(name); req.name = name; next(); }); router.get(&apos;/hello/:name&apos;, function(req, res) { res.send(&apos;hello &apos; + req.name + &apos;!&apos;); }); 上面代码中，get方法为访问路径指定了name参数，param方法则是对name参数进行处理。注意，param方法必须放在HTTP动词方法之前。 `]]></content>
      <categories>
        <category>后端</category>
        <category>NODE</category>
        <category>Express</category>
      </categories>
      <tags>
        <tag>NODE</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUEX]]></title>
    <url>%2F2017%2F11%2F16%2FVUEX%2F</url>
    <content type="text"><![CDATA[Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 Vuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。说白了就是控制应用的一些全局状态。状态改变了，对应的视图也会改变。 什么是“状态管理模式”？123456789101112131415161718new Vue(&#123; // state 模型(model) data () &#123; return &#123; count: 0 &#125; &#125;, // view 视图(view) template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // actions 控制器(controller) methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;) 这个状态自管理应用包含以下几个部分： state，驱动应用的数据源 view，以声明方式将 state 映射到视图； actions，响应在 view 上的用户输入导致的状态变化。 以下是一个表示“单向数据流”理念的极简示意： 为什么使用vuex 传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力 多个视图依赖于同一状态。或者 来自不同视图的行为需要变更同一状态。 VUEX 流程 从上图可以看出 在 vue Components 派发了（dispatch) 一个行为 (Actions) 在Actions 中通过 commit 去触发转变 (Mutations ) 在Mutations 中去更新 state 最后触发视图的更新 VUEX 核心概念State state 定义了应用状态的数据结构，同样可以在这里设置默认的初始状态。 123456export default &#123; user: &#123; nickname : &apos;这是一只二哈&apos;, login_name : &apos;&apos;, &#125;&#125; Action Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 Actions 即是定义提交触发更改信息的描述，常见的例子有从服务端获取数据，在数据获取完成后会调用store.commit()来调用更改 Store 中的状态。可以在组件中使用dispatch来发出 Actions。1234567891011export default &#123; setUser :(context ,data=&#123;&#125;)=&gt;&#123; console.log(&apos;context =========&gt;&apos;,context ); console.log(&apos;这是mutations=========&gt;&apos;,data); context.commit(&apos;SET_USER&apos;,data) &#125;, setLoginStatus:(&#123;commit&#125;,data=&#123;&#125;)=&gt;&#123; console.log(&apos;这是mutations=========&gt;&apos;,data); commit(&apos;SET_LOGINSTATUS&apos;,data); &#125;&#125; 在组件中分发 Action在Actions对象中 对应的键是暴露在外面 可以用this.$store.dispatch(&#39;xxx&#39;) 触发 或者 在视图中用mapActions 辅助函数将 组件的method 映射为1234567891011121314151617181920import &#123; mapActions &#125; from &apos;vuex&apos;export default &#123; // ... methods: &#123; ...mapActions([ // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` &apos;increment&apos;, // `mapActions` 也支持载荷： // 将 `this.incrementBy(amount)` 映射为 // `this.$store.dispatch(&apos;incrementBy&apos;, amount)` &apos;incrementBy&apos; ]), ...mapActions(&#123; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` add: &apos;increment&apos; &#125;) &#125;&#125; 组合 ActionAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：12345678910actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit(&apos;someMutation&apos;) resolve() &#125;, 1000) &#125;) &#125;&#125; 现在你可以：123store.dispatch(&apos;actionA&apos;).then(() =&gt; &#123; // ...&#125;) 在另外一个 action 中也可以：12345678actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch(&apos;actionA&apos;).then(() =&gt; &#123; commit(&apos;someOtherMutation&apos;) &#125;) &#125;&#125; 最后，如果我们利用 async / await 这个 JavaScript 即将到来的新特性，我们可以像这样组合 action：1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit(&apos;gotData&apos;, await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch(&apos;actionA&apos;) // 等待 actionA 完成 commit(&apos;gotOtherData&apos;, await getOtherData()) &#125;&#125; Mutation mutations: 调用 mutations 是唯一允许更新应用状态的地方。 Mutation 必须是同步函数 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) 你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：1store.commit(&apos;increment&apos;,data) Mutation 需遵守 Vue 的响应规则既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, &#39;newProp&#39;, 123), 或者 以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：state.obj = { ...state.obj, newProp: 123 } Getter有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。 Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数：12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Getter 会暴露为 store.getters 对象：1store.getters.doneTodos // -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;] Getter 也可以接受其他 getter 作为第二个参数：1234567getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125;store.getters.doneTodosCount // -&gt; 1 我们可以很容易地在任何组件中使用它：12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; mapGetters 辅助函数mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：12345678910111213import &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ &apos;doneTodosCount&apos;, &apos;anotherGetter&apos;, // ... ]) &#125;&#125; 如果你想将一个 getter 属性另取一个名字，使用对象形式：1234mapGetters(&#123; // 映射 `this.doneCount` 为 `store.getters.doneTodosCount` doneCount: &apos;doneTodosCount&apos;&#125;) 插件Vuex 的 store 接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数：1234567const myPlugin = store =&gt; &#123; // 当 store 初始化后调用 store.subscribe((mutation, state) =&gt; &#123; // 每次 mutation 之后调用 // mutation 的格式为 &#123; type, payload &#125; &#125;)&#125; 然后像这样使用：1234const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 在插件内提交 Mutation在插件中不允许直接修改状态——类似于组件，只能通过提交 mutation 来触发变化。 通过提交 mutation，插件可以用来同步数据源到 store。例如，同步 websocket 数据源到 store（下面是个大概例子，实际上 createPlugin 方法可以有更多选项来完成复杂任务）：12345678910111213141516171819export default function createWebSocketPlugin (socket) &#123; return store =&gt; &#123; socket.on(&apos;data&apos;, data =&gt; &#123; store.commit(&apos;receiveData&apos;, data) &#125;) store.subscribe(mutation =&gt; &#123; if (mutation.type === &apos;UPDATE_DATA&apos;) &#123; socket.emit(&apos;update&apos;, mutation.payload) &#125; &#125;) &#125;&#125;const plugin = createWebSocketPlugin(socket)const store = new Vuex.Store(&#123; state, mutations, plugins: [plugin]&#125;) 内置 Logger 插件Vuex 自带一个日志插件用于一般的调试:12345import createLogger from &apos;vuex/dist/logger&apos;const store = new Vuex.Store(&#123; plugins: [createLogger()]&#125;) createLogger 函数有几个配置项：12345678910111213141516171819const logger = createLogger(&#123; collapsed: false, // 自动展开记录的 mutation filter (mutation, stateBefore, stateAfter) &#123; // 若 mutation 需要被记录，就让它返回 true 即可 // 顺便，`mutation` 是个 &#123; type, payload &#125; 对象 return mutation.type !== &quot;aBlacklistedMutation&quot; &#125;, transformer (state) &#123; // 在开始记录之前转换状态 // 例如，只返回指定的子树 return state.subTree &#125;, mutationTransformer (mutation) &#123; // mutation 按照 &#123; type, payload &#125; 格式记录 // 我们可以按任意方式格式化 return mutation.type &#125;, logger: console, // 自定义 console 实现，默认为 `console`&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 生成 ssh key]]></title>
    <url>%2F2017%2F11%2F15%2FgitHub_1%2F</url>
    <content type="text"><![CDATA[Git 生成 ssh key1. 打开 git bash1ssh-keygen -t rsa -C &quot;youremail@exmple.com&quot; 一直回车就可以 如果想每次push时候输入密码 就填写push时候输入的密码 2. 测试OK。输入命令1ssh -T git@github.com 3. 配置Git 账户信息 直接执行就好了 没有信息提示1git config --global user.name &quot;username&quot; 1git config --global user.email &quot;email&quot; 执行以上步骤 可以生成SSH key 4. 查看SSH KEY1cat ~/.ssh/id_rsa.pub 出现如下图红色框区域 以ssh-rsa 开头 以邮箱结尾 则证明电脑存在公钥然后在githun账号中配置 上公钥即可]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment copyright 是否显示文章下面转载信息top 置顶的意思 参数越大 文章越靠上]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node-fs]]></title>
    <url>%2F2017%2F11%2F15%2Fnode-fs%2F</url>
    <content type="text"><![CDATA[fs 模块一、同步 和 异步 Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。 readFile读取文件 创建 input.txt 文件，内容如下：line one 在text.txt相同目录中有一个readfile.js，内容如下 readFile的回调函数接收两个参数： err是读取文件出错时触发的错误对象， data是从文件读取的数据。 123456789var fs = require(&apos;fs&apos;); // 引入fs模块fs.readFile(&apos;./test.txt&apos;, function(err, data) &#123; // 读取文件失败/错误 if (err) &#123; throw err; &#125; // 读取文件成功 console.log(data);&#125;); $ node readfile.js运行结果1&lt;Buffer 6c 69 6e 65 20 6f 6e 65 0a 6c 69 6e 65 20 74 77 6f 0a&gt; 这是原始二进制数据在缓冲区中的内容。 要显示文件内容可以使用toString()或者设置输出编码。 toString()写法：123456789// 使用toString()fs.readFile(&apos;./test.txt&apos;, function(err, data) &#123; // 读取文件失败/错误 if (err) &#123; throw err; &#125; // 读取文件成功 console.log(data.toString());&#125;); 设置utf-8编码写法：// 设置编码格式 fs.readFile(&#39;./test.txt&#39;, &#39;utf-8&#39;, function(err, data) { // 读取文件失败/错误 if (err) { throw err; } // 读取文件成功 console.log(&#39;utf-8: &#39;, data.toString()); //直接用console.log(data);也可以 }); readFile同步的写法就是没有回调函数：fs.readFileSync(filename,[options])。]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
</search>
